package tun

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// detectGateway detects the current default gateway and interface on Linux.
func detectGateway() (gateway, iface string, err error) {
	out, err := exec.Command("ip", "route", "show", "default").Output()
	if err != nil {
		return "", "", fmt.Errorf("failed to detect default gateway: %w", err)
	}

	// Expected format: "default via <gw> dev <iface> ..."
	fields := strings.Fields(strings.TrimSpace(string(out)))
	for i, f := range fields {
		if f == "via" && i+1 < len(fields) {
			gateway = fields[i+1]
		}
		if f == "dev" && i+1 < len(fields) {
			iface = fields[i+1]
		}
	}

	if gateway == "" || iface == "" {
		return "", "", fmt.Errorf("could not parse default gateway from: %s", string(out))
	}
	return gateway, iface, nil
}

// addBypassRoutes adds host routes for remote server IPs via the original gateway.
func addBypassRoutes(remoteAddrs []string, gateway string) error {
	for _, addr := range remoteAddrs {
		if err := run("ip", "route", "add", addr+"/32", "via", gateway); err != nil {
			return fmt.Errorf("failed to add bypass route for %s: %w", addr, err)
		}
	}
	return nil
}

// removeBypassRoutes removes the bypass host routes.
func removeBypassRoutes(remoteAddrs []string) error {
	var firstErr error
	for _, addr := range remoteAddrs {
		if err := run("ip", "route", "delete", addr+"/32"); err != nil && firstErr == nil {
			firstErr = fmt.Errorf("failed to remove bypass route for %s: %w", addr, err)
		}
	}
	return firstErr
}

// setDefaultRouteTUN replaces the default route to go through the TUN device.
func setDefaultRouteTUN(tunDevice string) error {
	if err := run("ip", "route", "replace", "default", "dev", tunDevice, "metric", "1"); err != nil {
		return fmt.Errorf("failed to set TUN default route: %w", err)
	}
	return nil
}

// restoreDefaultRoute restores the original default route.
func restoreDefaultRoute(gateway string) error {
	// Remove TUN route (ignore errors — may already be gone).
	run("ip", "route", "delete", "default", "metric", "1")
	if err := run("ip", "route", "replace", "default", "via", gateway); err != nil {
		return fmt.Errorf("failed to restore default route via %s: %w", gateway, err)
	}
	return nil
}

const resolveConfBackup = "/etc/resolv.conf.raycoon.bak"

// configureDNS backs up /etc/resolv.conf and writes a new one with the given DNS server.
func configureDNS(dnsServer string) error {
	// Read current resolv.conf.
	data, err := os.ReadFile("/etc/resolv.conf")
	if err != nil {
		return fmt.Errorf("failed to read /etc/resolv.conf: %w", err)
	}

	// Save backup.
	if err := os.WriteFile(resolveConfBackup, data, 0644); err != nil {
		return fmt.Errorf("failed to backup /etc/resolv.conf: %w", err)
	}

	// Write new resolv.conf.
	newConf := fmt.Sprintf("# Generated by raycoon TUN mode\nnameserver %s\n", dnsServer)
	if err := os.WriteFile("/etc/resolv.conf", []byte(newConf), 0644); err != nil {
		return fmt.Errorf("failed to write /etc/resolv.conf: %w", err)
	}

	return nil
}

// restoreDNS restores /etc/resolv.conf from backup.
func restoreDNS() error {
	data, err := os.ReadFile(resolveConfBackup)
	if err != nil {
		// No backup — nothing to restore.
		return nil
	}

	if err := os.WriteFile("/etc/resolv.conf", data, 0644); err != nil {
		return fmt.Errorf("failed to restore /etc/resolv.conf: %w", err)
	}

	os.Remove(resolveConfBackup)
	return nil
}

func run(name string, args ...string) error {
	cmd := exec.Command(name, args...)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%w: %s", err, strings.TrimSpace(string(output)))
	}
	return nil
}
