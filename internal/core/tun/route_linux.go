package tun

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// detectGateway detects the current default gateway and interface on Linux.
func detectGateway() (gateway, iface string, err error) {
	out, err := exec.Command("ip", "route", "show", "default").Output()
	if err != nil {
		return "", "", fmt.Errorf("failed to detect default gateway: %w", err)
	}

	// Expected format: "default via <gw> dev <iface> ..."
	fields := strings.Fields(strings.TrimSpace(string(out)))
	for i, f := range fields {
		if f == "via" && i+1 < len(fields) {
			gateway = fields[i+1]
		}
		if f == "dev" && i+1 < len(fields) {
			iface = fields[i+1]
		}
	}

	if gateway == "" || iface == "" {
		return "", "", fmt.Errorf("could not parse default gateway from: %s", string(out))
	}
	return gateway, iface, nil
}

// configureTUNAddress assigns a point-to-point IP address to the TUN device.
func configureTUNAddress(deviceName, addr string) error {
	if err := run("ip", "addr", "add", addr+"/30", "dev", deviceName); err != nil {
		return fmt.Errorf("failed to add address to %s: %w", deviceName, err)
	}
	if err := run("ip", "link", "set", deviceName, "up"); err != nil {
		return fmt.Errorf("failed to bring up %s: %w", deviceName, err)
	}
	return nil
}

// addBypassRoutes adds host routes for remote server IPs via the original gateway.
func addBypassRoutes(remoteAddrs []string, gateway string) error {
	for _, addr := range remoteAddrs {
		if err := run("ip", "route", "add", addr+"/32", "via", gateway); err != nil {
			return fmt.Errorf("failed to add bypass route for %s: %w", addr, err)
		}
	}
	return nil
}

// removeBypassRoutes removes the bypass host routes.
func removeBypassRoutes(remoteAddrs []string) error {
	var firstErr error
	for _, addr := range remoteAddrs {
		if err := run("ip", "route", "delete", addr+"/32"); err != nil && firstErr == nil {
			firstErr = fmt.Errorf("failed to remove bypass route for %s: %w", addr, err)
		}
	}
	return firstErr
}

// setDefaultRouteTUN captures all traffic through the TUN device by adding two
// /1 routes more specific than the default (0/0). The original default route
// is never removed, making cleanup and crash recovery safer.
func setDefaultRouteTUN(tunDevice string) error {
	if err := run("ip", "route", "add", "0.0.0.0/1", "dev", tunDevice); err != nil {
		return fmt.Errorf("failed to add 0/1 TUN route: %w", err)
	}
	if err := run("ip", "route", "add", "128.0.0.0/1", "dev", tunDevice); err != nil {
		// Roll back the first route.
		run("ip", "route", "del", "0.0.0.0/1")
		return fmt.Errorf("failed to add 128/1 TUN route: %w", err)
	}
	return nil
}

// restoreDefaultRoute removes the /1 overlay routes and ensures the original
// default route is present. Handles both new (/1 overlay) and old (metric-1
// default replacement) code for crash-recovery across upgrades.
func restoreDefaultRoute(gateway string) error {
	// Remove /1 overlay routes (new approach). Ignore errors.
	run("ip", "route", "del", "0.0.0.0/1")
	run("ip", "route", "del", "128.0.0.0/1")
	// Remove old metric-1 default route if present (old approach).
	run("ip", "route", "delete", "default", "metric", "1")
	// Ensure the original default route is present.
	if err := run("ip", "route", "replace", "default", "via", gateway); err != nil {
		return fmt.Errorf("failed to restore default route via %s: %w", gateway, err)
	}
	return nil
}

const resolveConfBackup = "/etc/resolv.conf.raycoon.bak"

// configureDNS backs up /etc/resolv.conf and writes a new one with the given DNS server.
func configureDNS(dnsServer string) error {
	// Read current resolv.conf.
	data, err := os.ReadFile("/etc/resolv.conf")
	if err != nil {
		return fmt.Errorf("failed to read /etc/resolv.conf: %w", err)
	}

	// Save backup.
	if err := os.WriteFile(resolveConfBackup, data, 0644); err != nil {
		return fmt.Errorf("failed to backup /etc/resolv.conf: %w", err)
	}

	// Write new resolv.conf.
	newConf := fmt.Sprintf("# Generated by raycoon TUN mode\nnameserver %s\n", dnsServer)
	if err := os.WriteFile("/etc/resolv.conf", []byte(newConf), 0644); err != nil {
		return fmt.Errorf("failed to write /etc/resolv.conf: %w", err)
	}

	return nil
}

// restoreDNS restores /etc/resolv.conf from backup.
func restoreDNS() error {
	data, err := os.ReadFile(resolveConfBackup)
	if err != nil {
		// No backup â€” nothing to restore.
		return nil
	}

	if err := os.WriteFile("/etc/resolv.conf", data, 0644); err != nil {
		return fmt.Errorf("failed to restore /etc/resolv.conf: %w", err)
	}

	os.Remove(resolveConfBackup)
	return nil
}

func run(name string, args ...string) error {
	cmd := exec.Command(name, args...)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%w: %s", err, strings.TrimSpace(string(output)))
	}
	return nil
}
